---
title: The Natural Numbers and Recursion
---

We all developed an intuitive understanding of the counting numbers back in kindergarten. But what exactly are they? Mathematics depends on having precise definitions, and we need one for the natural numbers.

Typically, the natural numbers are developed using the *Peano axioms*: these axioms assert the existence of a set \\(N\\) with an element 0 and a function \\(S : N \\rightarrow N\\) which satisfy the following.

1. \\(0 = S(n)\\) does not have a solution \\( n \\in N \\).
2. If \\(S(n) = S(m)\\), then \\(n = m\\).
3. If \\(B\\) is a set such that \\(0 \\in B\\) and whenever \\(n \\in B\\) we also have \\(S(n) \\in B\\), then in fact \\(N \\subseteq B\\).

We will take a slightly different approach, which in this author's opinion helps prepare our minds for some very cool ideas.

**Iterative Sets**

The basic setup of the Peano axioms - the element 0 and the function \\(S\\) - form a kind of structure on \\(N\\), which we give a name.

<div class="result">
<div class="defn">
<p>A set \\(A\\) with a distinguished element \\(e\\) and a distinguished function \\(\\varphi : A \\rightarrow A\\) is called an *iterative set*.</p>
</div>
</div>

We can think of an iterative set as a very primitive kind of algebra. There's not much we can do with one, though, except construct a list of successive values: \\[ e, \\quad \\varphi(e), \\quad \\varphi(\\varphi(e)), \\quad \\varphi(\\varphi(\\varphi(e))), \\quad \\ldots. \\] Not all of these successive values have to be distinct, however. For instance, we can define a set \\(\\bool = \\{ \\btrue, \\bfalse \\}\\) and a function \\(\\bnot : \\bool \\rightarrow \\bool\\) by \\(\\bnot(\\btrue) = \\bfalse\\) and \\(\\bnot(\\bfalse) = \\btrue\\). Now \\((\\bool, \\btrue, \\bnot)\\) is an iterative set, but the sequence of values generated by \\(\\bnot\\) repeats: \\[ \\btrue, \\quad \\bnot(\\btrue) = \\bfalse, \\quad \\bnot(\\bnot(\\btrue)) = \\btrue, \\quad \\bnot(\\bnot(\\bnot(\\btrue))) = \\bfalse, \\quad \\ldots.\\]

As a kind of algebra, however, the iterative sets come with a corresponding class of structure-preserving maps. In this case, the only structure to be preserved is the distinguished element and the distinguished function.

<div class="result">
<div class="defn">
<p>Suppose \\((A,e,\\varphi)\\) and \\((B,f,\\psi)\\) are iterative sets. A mapping \\(\\theta : A \\rightarrow B\\) is called an *iterative homomorphism* if \\(\\theta(e) = f\\) and \\(\\theta(\\varphi(x)) = \\psi(\\theta(x))\\) for all \\(x \\in A\\).</p>
</div>
</div>

It is straightforward to show that the identity function \\(\\id\\) is always an iterative homomorphism and that the composite of two homomorphisms is a homomorphism. So the iterative sets form a category (if you're into that).

**Natural Numbers**

As an axiom, we define the natural numbers to be a special iterative set.

<div class="result">
<div class="axiom">
<p>There is a special inductive set \\((\\nats,\\zero,\\next)\\) which has the following *universal property*: if \\((A,e,\\varphi)\\) is an inductive set, then there is a unique iterative homomorphism \\(\\Theta : \\nats \\rightarrow A\\). This unique function \\(\\Theta\\) will be denoted \\(\\natrec{e}{\\varphi}\\).</p>
</div>
</div>

At first this may seem like a strange definition. By repeatedly applying the \\(\\next\\) function to \\(\\zero\\), we get the successive values \\[\\zero, \\quad \\next(\\zero), \\quad \\next(\\next(\\zero)), \\quad \\next(\\next(\\next(\\zero))), \\quad \\ldots\\] which (assuming they are all distinct!) resemble the Peano numbers. But what sets \\(\\nats\\) apart from the other iterative sets is the special function \\(\\natrec{\\ast}{\\ast}\\): given any other iterative set \\(A\\), there is exactly one homomorphism from \\(\\nats\\) to \\(A\\).

Applying this function to the sequence of elements above, we see that \\(\\natrec{e}{\\varphi}(\\zero) = e\\) (of course), and then \\[ \\natrec{e}{\\varphi}(\\next(\\zero)) = \\varphi(\\natrec{e}{\\varphi}(\\zero)) = \\varphi(e), \\] \\[ \\natrec{e}{\\varphi}(\\next(\\next(\\zero))) = \\varphi(\\natrec{e}{\\varphi}(\\next(\\zero))) = \\varphi(\\varphi(e)), \\] \\[ \\natrec{e}{\\varphi}(\\next(\\next(\\next(\\zero)))) = \\varphi(\\natrec{e}{\\varphi}(\\next(\\next(\\zero)))) = \\varphi(\\varphi(\\varphi(e))), \\] and so on.

The \\(\\natrec{\\ast}{\\ast}\\) function encapsulates the basic pattern of *recursion* on the natural numbers, as we will see. Importantly, it does so in a well-behaved way; reasoning about recursive functions defined using \\(\\natrec{\\ast}{\\ast}\\) can be very easy.

**The Peano Properties**

As an example, lets show that our natural numbers satisfy the more traditional Peano axioms.

<div class="result">
<div class="lemma">
<p>There is not a natural number \\(m\\) such that \\(\\zero = \\next(m)\\).</p>
</div>

<div class="proof">
Suppose to the contrary that \\(\\next(m) = \\zero\\). Note that \\((\\bool, \\btrue, \\const(\\bfalse))\\) is an iterative set. Let \\(\\Theta\\) denote the unique iterative homomorphism \\(\\natrec{\\btrue}{\\const(\\bfalse)} : \\nats \\rightarrow \\bool\\).

We thus have \\[ \\btrue = \\Theta(\\zero) = \\Theta(\\next(m)) = (\\const(\\bfalse))(\\Theta(m)) = \\bfalse, \\] which is absurd.
</div>
</div>




The induction principle

<div class="result">
<div class="theorem">
Suppose \\(f : \\nats \\rightarrow A\\) is a map and that \\(B \\subseteq A\\) is a subset such that \\(f(\\zero) \\in B\\) and whenever \\(f(n) \\in B\\), we also have \\(f(\\next(n)) \\in B\\). Then in fact \\(f(n) \\in B\\) for all natural numbers \\(n\\).
</div>

<div class="proof">
Define a subset \\(T \\subseteq \\nats\\) by \\[ T = \\{n \\in \\nats \\mid f(n) \\in B \\}. \\] By hypothesis, we have \\(\\zero \\in T\\). Also, if \\(n \\in T\\), then \\(\\next(n) \\in T\\); in particular, the restriction of \\(\\next\\) to \\(T\\) is in fact a function \\(T \\rightarrow T\\). That is, \\((T,\\zero,\\next)\\) is an iterative set. Let \\(\\Theta = \\natrec{\\zero}{\\next}\\) be the unique homomorphism \\(\\nats \\rightarrow T\\).

Now let \\(\\iota : T \\rightarrow \\nats\\) denote the inclusion map; in fact \\(\\iota\\) is an iterative homomorphism, wince we have \\(\\iota(\\zero) = \\zero\\) and \\[ \\iota(\\next(n)) = \\next(n) = \\next(\\iota(n)) \\] for all \\(n \\in T\\).

The composite map \\(\\iota \\circ \\Theta : \\nats \\rightarrow \\nats\\) is again an iterative homomorphism, and by uniqueness, in fact we have \\(\\iota \\circ \\Theta = \\id\\). If \\(n\\) is a natural number, we have \\[ n = \\id(n) = \\iota(\\Theta(n)) = \\Theta(n), \\] and in particular, \\(n \\in T\\). That is, if \\(n\\) is any natural number, we have \\(f(n) \\in B\\).
</div>
</div>

**Haskell Implementation**

Another nice consequence of wrapping up recursion in the \\(\\natrec{\\ast}{\\ast}\\) function is that it allows us to **write executable programs, independent of any implementation, and prove things about them**. We'll see some examples of this in a moment.

First we need to establish a structural result: every natural number is either \\(\\zero\\) or of the form \\(\\next(n)\\) for some \\(n\\).

<div class="result">
<div class="lemma">
<p>If \\(n \\in \\mathbb{N}\\), then either \\(n = \\zero\\) or \\(n = \\next(m)\\) for some \\(m\\).</p>
</div>

<div class="proof">
Suppose to the contrary that there is an element \\(s \\in \\nats\\), not equal to \\(\\zero\\), which is not of the form \\(\\next(m)\\) for some \\(m\\). Note that \\(\\bool\\), with the distinguished element \\(\\btrue\\) and the constant function \\(\\const(\\btrue) : \\bool \\rightarrow \\bool\\), is an iterative set. Let \\(\\Theta\\) denote the unique iterative homomorphism \\(\\natrec{\\btrue}{\\const(\\btrue)} : \\nats \\rightarrow \\bool\\).

Now we define another mapping \\(\\Psi : \\nats \\rightarrow \\bool\\) as follows: \\[ \\Psi(x) = \\left\\{ \\begin{array}{ll} \\Theta(x) & \\mathrm{if}\\ x \\neq s \\\\ \\bnot(\\Theta(x)) & \\mathrm{if}\\ x = s \\end{array} \\right. \\] We claim that \\(\\Psi\\) is an iterative homomorphism. To see this, note that \\[\\Psi(\\zero) = \\Theta(\\zero) = \\btrue\\] (since \\(\\zero \\neq s\\)) and that if \\(x \\in \\nats\\), \\[ \\Psi(\\next(x)) = \\Theta(\\next(x)) = (\\const\\ \\btrue)(\\Theta(x)) = \\btrue = (\\const\\ \\btrue)(\\Psi(x)) \\] (since \\(\\next(x) \\neq s\\)). That is, \\(\\Psi\\) is an iterative homomorphism from \\((\\nats, \\zero, \\next)\\) to \\((\\bool, \\btrue, \\const(\\btrue))\\), and since \\(\\Theta\\) is unique, we have \\(\\Psi = \\Theta\\). But this implies that \\(\\Theta(s) = \\Psi(s) = \\bnot(\\Theta(s))\\), which is absurd.
</div>
</div>

> module Natural where
>
> data Nat
>  = Zero | Next Nat
>  deriving (Eq, Show)

> natRecur :: a -> (a -> a) -> Nat -> a
> natRecur e _ Zero     = e
> natRecur e f (Next n) = f (natRecur e f n)

> nat0 = Zero
> nat1 = Next nat0
> nat2 = Next nat1
> nat3 = Next nat2
> nat4 = Next nat3
> nat5 = Next nat4
> nat6 = Next nat5
> nat7 = Next nat6
> nat8 = Next nat7
> nat9 = Next nat8
